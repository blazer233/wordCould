<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Demo</title>
  </head>
  <body>
    <!-- 未添加边缘碰撞测试，如果有边缘问题则移除元素 -->
    <canvas id="canvas" style="background-color: antiquewhite"></canvas>
    <script src="./data.js"></script>
    <script src="./tool.js"></script>
    <script>
      /** 辅助函数, 绘制阿基米德螺线
       * @param {*} size 画布大小, [width, height]
       * @param {*} getPosition 布局函数, 调用archimedeanSpiral获取的返回值
       * @param {*} params { showIndex } 是否显示序号
       */
      const paintSpiral = (
        size,
        getPosition,
        baseData = [],
        showIndex = true
      ) => {
        baseData.sort((a, b) => b.fontSize - a.fontSize);
        const ctx = canvas.getContext("2d");
        canvas.width = size[0];
        canvas.height = size[1];
        const points = []; // 所有放置点
        let last = [0, 0];
        let maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), // 最大半径（勾股定理）
          t = 1, // 阿基米德弧度
          dxdy,
          dx, // x坐标
          dy; // y坐标
        // 通过每次增加的步长固定为1，实际步长为 step * 1，来获取下一个放置点
        do {
          dxdy = getPosition(t);
          dx = dxdy[0];
          dy = dxdy[1];
          x = dx + size[0] / 2;
          y = dy + size[1] / 2;
          t++;
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break; // (dx, dy)距离中心超过maxDelta，跳出螺旋返回false
          points.push({ dx, dy, x, y });
        } while (true);
        baseData.forEach((item, i) => {
          item.text = showIndex ? `${i}${item.text}` : item.text;
          item._height = item.fontSize * 1.2;
          item = Object.assign(item, points[i]);
        });
        let lastOne = [];
        let outLineOne = [];
        /*画辅助线*/
        // points.forEach((point, index) => {
        //   ctx.beginPath();
        //   ctx.moveTo(last[0] + size[0] / 2, last[1] + size[1] / 2);
        //   ctx.lineTo(point.dx + size[0] / 2, point.dy + size[1] / 2);
        //   last = [point.dx, point.dy];
        //   ctx.stroke();
        //   ctx.beginPath();
        //   ctx.arc(
        //     point.dx + size[0] / 2,
        //     point.dy + size[1] / 2,
        //     2,
        //     0,
        //     2 * Math.PI,
        //     false
        //   );
        // });

        // 将放置点绘制出来
        for (let i = 0; i < baseData.length; i++) {
          let point = baseData[i];
          ctx.fillStyle = point.color;
          ctx.font = point.fontSize + "px Arial";
          point._width = ctx.measureText(point.text).width;
          ctx.beginPath();
          if (lastOne.length) {
            // true 没碰上
            // false 碰上了
            let s = i;
            while (!lastOne.every(one => hitTest(point, one))) {
              point = Object.assign(point, points[s]);
              s++;
              if (s == points.length - 1) break;
            }
          }
          lastOne.push(point);
          ctx.fillText(point.text, point.x, point.y + point._height);
        }
        console.log(points, lastOne, outLineOne, canvas);
      };
      const getPosition = archimedeanSpiral(CANVAS_SIZE, { step: 1, b: 0.5 });
      paintSpiral(CANVAS_SIZE, getPosition, baseData);
    </script>
  </body>
</html>
