<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Demo</title>
  </head>
  <body>
    <canvas id="canvas" style="background-color: antiquewhite"></canvas>
    <script src="./data.js"></script>
    <script src="./tool.js"></script>
    <script>
      const paintSpiral = (
        size,
        getPosition,
        baseData = [],
        showIndex = false,
        isSpiral = false
      ) => {
        baseData.sort((a, b) => b.fontSize - a.fontSize);
        const ctx = canvas.getContext("2d");
        canvas.width = size[0];
        canvas.height = size[1];
        const points = []; // 所有放置点
        let last = [0, 0];
        let maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), // 最大半径（勾股定理）
          t = 1, // 阿基米德弧度
          dxdy,
          dx, // x坐标
          dy; // y坐标
        // 通过每次增加的步长固定为1，实际步长为 step * 1，来获取下一个放置点
        do {
          dxdy = getPosition(t);
          dx = dxdy[0];
          dy = dxdy[1];
          x = dx + size[0] / 2;
          y = dy + size[1] / 2;
          t++;
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break; // (dx, dy)距离中心超过maxDelta，跳出螺旋返回false
          points.push({ dx, dy, x, y });
        } while (true);
        // points.length = baseData.length;
        baseData.forEach((item, i) => {
          item.text = showIndex ? `${i}${item.text}` : item.text;
          item._height = item.fontSize * 1.2;
          item = Object.assign(item, points[i]);
        });
        let lastOne = [];
        /*画辅助线*/
        if (isSpiral) {
          points.forEach((point, index) => {
            ctx.beginPath();
            ctx.moveTo(last[0] + size[0] / 2, last[1] + size[1] / 2);
            ctx.lineTo(point.dx + size[0] / 2, point.dy + size[1] / 2);
            last = [point.dx, point.dy];
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(
              point.dx + size[0] / 2,
              point.dy + size[1] / 2,
              2,
              0,
              2 * Math.PI,
              false
            );
          });
        }

        // 将放置点绘制出来
        for (let i = 0; i < baseData.length; i++) {
          let point = baseData[i];
          ctx.fillStyle = point.color;
          ctx.font = point.fontSize + "px Arial";
          point._width = ctx.measureText(point.text).width;
          ctx.beginPath();
          if (lastOne.length) {
            let s = i;
            while (
              !lastOne.every(
                one => hitTest(point, one) && !outLineTest(point, size)
              )
            ) {
              point = Object.assign(point, points[s]);
              s++;
              if (s == points.length - 1) break;
            }
          } else {
            point.x = point.x - point._width / 2;
            point.y = point.y - point._height / 2;
          }
          lastOne.push(point);
          // /*画文字*/
          ctx.fillText(point.text, point.x, point.y + point._height);
          // /*画框*/
          // ctx.strokeRect(point.x, point.y, point._width, point._height);
        }
        console.log(points, lastOne, outLineOne, canvas);
      };
      const getPosition = archimedeanSpiral(CANVAS_SIZE, { step: 0.1, b: 1.2 });
      paintSpiral(CANVAS_SIZE, getPosition, baseData);
    </script>
  </body>
</html>
