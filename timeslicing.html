<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Demo</title>
  </head>
  <body>
    <canvas id="canvas" style="background-color: antiquewhite"></canvas>
    <script src="./data.js"></script>
    <script src="./tool.js"></script>
    <script>
      // 接受一个 generator 函数
      function timeSlice(gen, ...arg) {
        // 传入参数生成 generator
        var g = gen(arg);
        if (!g || typeof g.next !== "function") return;
        return function next() {
          //记录当前时间
          var start = performance.now();
          var res = null;
          do {
            // 迭代一次
            // 可以理解为 执行一个任务
            res = g.next();
          } while (res.done !== true && performance.now() - start < 16);
          if (res.done) return; //generator 已经迭代完了，所有分割的任务都完成了
          setTimeout(next); // 将剩余的任务放在下一次 宏任务 执行
        };
      }
      function* paintSpiral(arg) {
        let [size, getPosition, baseData, isSpiral, showIndex] = arg;
        baseData.sort((a, b) => b.fontSize - a.fontSize);
        const ctx = canvas.getContext("2d");
        canvas.width = size[0];
        canvas.height = size[1];
        const points = []; // 所有放置点
        let last = [0, 0];
        let maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), // 最大半径（勾股定理）
          t = 1, // 阿基米德弧度
          dxdy,
          dx, // x坐标
          dy; // y坐标
        // 通过每次增加的步长固定为1，实际步长为 step * 1，来获取下一个放置点
        do {
          dxdy = getPosition(t);
          dx = dxdy[0];
          dy = dxdy[1];
          x = dx + size[0] / 2;
          y = dy + size[1] / 2;
          t++;
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break; // (dx, dy)距离中心超过maxDelta，跳出螺旋返回false
          points.push({ dx, dy, x, y });
        } while (true);
        baseData.forEach((item, i) => {
          item.text = showIndex ? `${i}${item.text}` : item.text;
          item._height = item.fontSize * 1.2;
          item = Object.assign(item, points[i]);
        });
        let lastOne = [];
        if (isSpiral) {
          points.forEach((point, index) => {
            ctx.beginPath();
            ctx.moveTo(last[0] + size[0] / 2, last[1] + size[1] / 2);
            ctx.lineTo(point.dx + size[0] / 2, point.dy + size[1] / 2);
            last = [point.dx, point.dy];
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(
              point.dx + size[0] / 2,
              point.dy + size[1] / 2,
              2,
              0,
              2 * Math.PI,
              false
            );
          });
        }
        let _i = 0;
        while (_i < baseData.length) {
          yield handleArray(ctx, lastOne, points, baseData, _i);
          _i++;
        }
        console.log(lastOne);
      }
      function handleArray(ctx, lastOne, points, baseData, i) {
        let point = baseData[i];
        ctx.fillStyle = point.color;
        ctx.font = point.fontSize + "px Arial";
        point._width = ctx.measureText(point.text).width;
        ctx.beginPath();
        if (lastOne.length) {
          let s = i;
          while (
            !lastOne.every(
              one => hitTest(point, one) && !outLineTest(point, size)
            )
          ) {
            point = Object.assign(point, points[s]);
            s++;
          }
        } else {
          point.x = point.x - point._width / 2;
          point.y = point.y - point._height / 2;
        }
        lastOne.push(point);
        // /*画文字*/
        ctx.fillText(point.text, point.x, point.y + point._height);
        // /*画框*/
        // ctx.strokeRect(point.x, point.y, point._width, point._height);
      }
      const getPosition = archimedeanSpiral(CANVAS_SIZE, { step: 0.1, b: 1.2 });
      timeSlice(paintSpiral, CANVAS_SIZE, getPosition, baseData)();
    </script>
  </body>
</html>
